#Written by Gary Zeri
#Member of the LaRue CatLab at Chapman University

#Graphable Abstract class to provide a common interface for all graphable objects in the CompChem Library

from abc import ABC, abstractmethod
from compChemGlobal import plot

class Graphable(ABC):
    
    #Declare all global variables here that should be modified in the child class 
    #to better reflect the actual titles
    graphTitle = "Generic & Unoriginal Graph Name"
    xTitle = "x"
    yTitle = "y"
    start = 0 
    end = 5
    forcedStart = None
    forcedEnd = None
    precision = 2
    resolution = 200
    graphableObjects = []
    graphableData = []
    isGraphable = True
    startBoundary = None
    endBoundary = None
    dash = "solid"
    group = ""
    graphCondition = None
    
    #Provide appropriate values for the global variables here in the child class
    @abstractmethod
    def __init__(self):
        
        #add in all objects that are graphable to this list in order to add their graphs to the graph  generated by this object
        #Need to make sure to clear this in the init in the child class
        self.graphableObjects = []
        self.graphableData = []
        
        #To signify if the child object has raw x,y data to graph or is a callable function to graph
        
        self.graphTitle = "Title"
        self.xTitle = "x"
        self.yTitle = "y"
        self.start = 0
        self.end = 0 
        self.precision = 2
        self.resolution = 100
    
###################################################################################

    #compute method that must be somewhere in the parent class in order to allow for graphing to occur
    @abstractmethod
    def value(self, r):
        pass

###################################################################################

    #method to return a list of widgets for this graphable object
    #if the graphable object is to have widgets beyond those which normally 
    #come with graphable objects
    #traces will be a list of traces availble to update as needed from the widgets end
    def getWidgets(self, x=None, y=None):
        return False
    
###################################################################################

    #showGraph: if True, graph wil be generated, if False, graph trace will be returned instead
    #rawData: if True, dictionary of x,y data will be returned instead
    def graph(self, showGraph=True, resolution=None, start=None, end=None, precision=None, startBoundary=None, endBoundary=None, getGraph=False, graphCondition=None):
        
        if(resolution == None):
            resolution = self.resolution 
        if(start == None):
            start = self.start
        if(end == None):
            end = self.end
        if(precision == None):
            precision = self.precision
        if(startBoundary == None):
            startBoundary = self.startBoundary
        if(endBoundary == None):
            endBoundary = self.endBoundary
        if(graphCondition == None):
            graphCondition = self.graphCondition
        
        if(self.isGraphable):
            trace = plot.graphFunction(self.value, title=self.graphTitle, resolution=resolution, 
                                       start=start, end=end, precision=precision, 
                                       xTitle=self.xTitle, yTitle=self.yTitle, 
                                       startBoundary=startBoundary, endBoundary=endBoundary, 
                                       dash=self.dash, group=self.group, graphCondition = graphCondition)
        else: 
            trace = None

        if(not showGraph):
            return trace
                
        return self.buildGraph(trace, getGraph)
        
###################################################################################

    #This is a private function that should not be overriden in the child class
    def buildGraph(self, trace, getGraph=False):

        data, functions, widgetObjs, boundaries = self.getGraphData(trace, self.value, self.startBoundary, self.endBoundary)
         
        fig = plot.go.FigureWidget(layout = dict( xaxis_title = self.xTitle, 
                                                  yaxis_title = self.yTitle, 
                                                  title_text = self.graphTitle
                                                ), 
                                   data = data
                                  )
        
        widgetData = plot.getGraphFunctionWidgets(fig, fig.data, functions, resolution=self.resolution, 
                                             start=self.start, end=self.end, precision=self.precision, returnWidgets=True, graphableData=len(self.graphableData), startBoundary=boundaries[0], endBoundary=boundaries[1])
        
        graph = widgetData[0]
        
        parentWidgets = self.getWidgets(graph.children[0].data, widgetData[1])
        if(parentWidgets != False):
            if(type(parentWidgets[0]) == list):
                for sublist in parentWidgets: 
                    widgetObjs.append(sublist)
            else: 
                widgetObjs.append(parentWidgets)
        
        index = 1
        for widgetList in widgetObjs:
            if(widgetList == False):
                continue
            
            if(index > len(graph.children)-1):
                graph.children += tuple([plot.widgets.HBox([])])
            graph.children[index].children += tuple(widgetList)
            index += 1
        
        if(getGraph):
            return graph
        else:
            display(graph)
        
###################################################################################

    #This is private function that should not be overriden in the child class
    def getGraphData(self, trace=None, function=None, startBoundary=None, endBoundary=None, graph=None):
        if(trace == None):
            traces = []
            functions = [] 
            boundaries = [[], []]
        else: 
            traces = [trace]
            functions = [function]
            boundaries = [startBoundary, endBoundary]

        widgets = []
        
        for graphableObject in self.graphableObjects:
            
            traces.append(graphableObject.graph(showGraph=False, 
   start=self.start if graphableObject.forcedStart == None else graphableObject.forcedStart,      end=self.end if graphableObject.forcedEnd == None else graphableObject.forcedEnd,          
   precision=self.precision, startBoundary=graphableObject.startBoundary, endBoundary=graphableObject.endBoundary))
            
            boundaries[0].append(graphableObject.startBoundary)
            boundaries[1].append(graphableObject.endBoundary)
            functions.append(graphableObject.value)
            widgets.append(graphableObject.getWidgets(0, 0))

        traces.extend(self.graphableData)
        return (traces, functions, widgets, boundaries)
    
###################################################################################

    def addGraphableObject(self, graphableObject):
        graphableObjects = [graphableObject]
        graphableObjects.extend(self.graphableObjects)
        self.graphableObjects = graphableObjects
        
###################################################################################

    def addGraphableData(self, graphableData, title):
        graphableData = [plot.buildTrace(x=graphableData["x"], y=graphableData["y"], title=title, 
                                                  precision=self.precision, xTitle=self.xTitle, 
                                                  yTitle=self.yTitle, mode="markers")]
        graphableData.extend(self.graphableData)
        self.graphableData = graphableData
        
###################################################################################
    
    def setGraphVariables(self, **kargs):
        
        for name in kargs: 
            try:
                getattr(self, name)
                setattr(self, name, kargs[name])
            except:
                print("'" + name + "' is not present in the current object and can not be modified.")
              
        return self