#Written by Gary Zeri
#Member of the LaRue CatLab at Chapman University

#Graphable Abstract class to provide a common interface for all graphable objects in the CompChem Library

from abc import ABC, abstractmethod
from compChemGlobal import plot

class Graphable(abc):
    
    #Declare all global variables here that should be modified in the child class 
    #to better reflect the actual titles
    graphTitle = "Generic & Unoriginal Graph Name"
    xTitle = "x"
    yTitle = "y"
    start = 0 
    end = 5
    precision = 2
    graphableObjects = []

    #Provide appropriate values for the global variables here in the child class
    @abstractmethod
    def __init__(self):
        
        #add in all objects that are graphable to this list in order to add their graphs to the graph  generated by this object
        graphableObjects = []
        
        graphTitle = "Title"
        xTitle = "x"
        yTitle = "y"
        start = 0
        end = 0 
        precision = 2
    
###################################################################################

    #compute method that must be somewhere in the parent class in order to allow for graphing to occur
    @abstractmethod
    def compute(self, r):
        pass

###################################################################################

    #method to return a list of widgets for this graphable object
    #if the graphable object should not have any widgets, then implement to return false
    @abstractmethod
    def getWidgets(self):
        return False
    
###################################################################################

    #showGraph: if True, graph wil be generated, if False, graph trace will be returned instead
    #rawData: if True, dictionary of x,y data will be returned instead
    def graph(self, showGraph=True, resolution=resolution, start=start, end=end, precision=precision):
        
        trace = plot.graphFunction(self.compute, title=graphTitle, resolution=resolution, 
                                       start=start, end=end, precision=precision, 
                                       xTitle=xTitle, yTitle=yTitle)
        
        if(not showGraph):
            return graphData
        
        data, functions, widgets = getGraphData(trace, self.compute)
        
        fig = plot.go.FigureWidget(layout = dict( xaxis_title = xTitle, 
                                                  yaxis_title=yTitle, 
                                                  title_text=graphTitle
                                                ), 
                                   data = self.buildGraphData(trace)
                                  )
        
        graph = plot.getGraphFunctionWidgets(fig, fig.data, self.getFunctions())
        
        #add in all the widgets from the graphableObjects list 
        for index, widget in enumerate(widgets):
            if(widget == False):
                continue
                
            graph.children[index].children += tuple(widget)

            
        display(graph)
        
###################################################################################

    #This is private function that should not be overriden in the child class
    def getGraphData(self, trace, function):
        traces = [trace]
        functions = [function]
        widgets = []
                                   
        for graphableObject in self.graphableObjects:
            traces.append(graphableObject.graph(showGraph=False))
            functions.append(graphableObject.compute)
            widgets.append(graphableObject.getWidgets())
        
        return (traces, functions, widgets)